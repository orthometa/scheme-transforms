;; archived code

;; this version of cps-letrec transforms letrec into lamdas+set
(define (cps-letrec e k)
  (let* ([bindings (second e)]
         [vars (map first bindings)]
         [val-exprs (map second bindings)]
         [body (drop e 2)])
    (cps
     `((lambda ,vars 
         (begin
           ,@(map (lambda (var val) `(set! ,var ,val))
                  vars val-exprs)
           ,@body))
       ,@(map (lambda (var) ''undef) vars))
     k)))

(define (cps-set e k)
  (let ([r (ngensym 'r)])
    (cps (set->val e)
         `(lambda (,r)
            (,k (set! ,(set->var e) ,r))))))

;; compilation to lambdas
(define (with-cps-primitives e ps)
  `((lambda (cps-prim)
      ((lambda ,(map (lambda (p) (cps-rename p)) ps)
         ,e)
       ,@(map (lambda (p) `(cps-prim ,p)) ps)))
    (lambda (f)
      (lambda (k . args)
        (k (apply f args))))))

;; from cps-letrec:
(begin
  (when (not (tagged-list? val 'church-make-stateless-xrp))
        (for-each display (list "WARNING: potential non-proc in letrec -- " val "\n")))
  (let ([k1 (ngensym 'klr2)])
    `(,f (call/cc
          (lambda (,k1)
            ,(cps val k1))))))

;; this version of cps-letrec makes use of letrec in the underlying scheme
(define (cps-letrec e k)
  `(letrec ,(map (lambda (def)
                   (let ([f (first def)]
                         [val (second def)])
                     (cond [(lambda? val)
                            (let ([vs (second val)]
                                  [fbody (third val)]
                                  [k1 (ngensym 'klr)])
                              `(,f (lambda (,k1 . ,vs)
                                     ,(cps fbody k1))))]
                           [(symbol? val)
                            `(,f ,val)]
                           [else
                            (error val "cps-letrec: binding values must be functions!")])))
                 (letrec->defns e))
     ,(cps (letrec->body e) k)))

(desugar-letrec
 `(letrec ([cps-prim (lambda (f)
                       (lambda (k . args)
                         (k (apply f args))))]
           ,@(map (lambda (p) `(,(cps-rename p) (cps-prim ,p)))
                  ps))
    ,e)))

;; cps-transform
;; 
;; input: expr like
;; (begin
;;   (define a (lambda args body))
;;   (define b (lambda args body))
;;   expr)
;; output:
;; (begin
;;   (define cps-prim-1 (lambda (k . args (k (apply prim-1 args)))))
;;   (define cps-prim-2 (lambda (k . args (k (apply prim-2 args)))))
;;   ...
;;   (define a (lambda (k . args) cps-body))
;;   (define b (lambda (k . args) cps-body))
;;   cps-expr)

;; (1) get true primitives of input expr with defines (get-free-vars
;;     must handle defines correctly)
;; (2) transform old top-level defines into cps style
;; (3) transform expr into cps style                                                                                         